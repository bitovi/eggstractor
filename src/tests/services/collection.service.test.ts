import {  getFlattenedValidNodes,  detectComponentSetDuplicates,  shouldExportAsComponentReference,  createComponentReferenceToken,} from '../../services/collection.service';import { TokenCollection, InstanceToken, ComponentToken, ComponentSetToken } from '../../types';describe('getFlattenedValidNodes', () => {  it('should filter out VECTOR and INSTANCE nodes', () => {    const testNode = {      type: 'FRAME',      name: 'test',      id: '1',      children: [        { type: 'VECTOR', name: 'vector1', id: '2' } as VectorNode,        { type: 'TEXT', name: 'text1', id: '3' } as TextNode,        { type: 'INSTANCE', name: 'instance1', id: '4' } as InstanceNode,        { type: 'RECTANGLE', name: 'rect1', id: '5' } as RectangleNode,      ],    } as unknown as FrameNode;    const { validNodes } = getFlattenedValidNodes(testNode);    const types = validNodes.map((node: BaseNode) => node.type);    expect(types).not.toContain('VECTOR');    expect(types).toContain('INSTANCE');    expect(types).toContain('FRAME');    expect(types).toContain('TEXT');    expect(types).toContain('RECTANGLE');  });  it('should filter out nodes with names starting with . or _', () => {    const testNode = {      type: 'FRAME',      name: 'test',      id: '1',      children: [        { type: 'TEXT', name: '.hidden', id: '2' } as TextNode,        { type: 'TEXT', name: '_private', id: '3' } as TextNode,        { type: 'TEXT', name: 'normal', id: '4' } as TextNode,      ],    } as unknown as FrameNode;    const { validNodes } = getFlattenedValidNodes(testNode);    const names = validNodes.map((node: BaseNode) => node.name);    expect(names).not.toContain('.hidden');    expect(names).not.toContain('_private');    expect(names).toContain('normal');    expect(names).toContain('test');  });});describe('detectComponentSetDuplicates', () => {  it('should detect no duplicates in valid component set', () => {    const componentSetNode = {      type: 'COMPONENT_SET',      name: 'Button',      id: '1',      children: [        { type: 'COMPONENT', name: 'Primary', id: '2' } as ComponentNode,        { type: 'COMPONENT', name: 'Secondary', id: '3' } as ComponentNode,      ],    } as ComponentSetNode;    const result = detectComponentSetDuplicates(componentSetNode);    expect(result.hasDuplicates).toBe(false);    expect(result.duplicateNames).toHaveLength(0);  });  it('should detect duplicates in component set', () => {    const componentSetNode = {      type: 'COMPONENT_SET',      name: 'Button',      id: '1',      children: [        { type: 'COMPONENT', name: 'Primary', id: '2' } as ComponentNode,        { type: 'COMPONENT', name: 'Primary', id: '3' } as ComponentNode,        { type: 'COMPONENT', name: 'Secondary', id: '4' } as ComponentNode,      ],    } as ComponentSetNode;    const result = detectComponentSetDuplicates(componentSetNode);    expect(result.hasDuplicates).toBe(true);    expect(result.duplicateNames).toContain('Primary');  });  it('should handle component set without children', () => {    const componentSetNode = {      type: 'FRAME',      name: 'NotAComponentSet',      id: '1',    } as BaseNode;    const result = detectComponentSetDuplicates(componentSetNode);    expect(result.hasDuplicates).toBe(false);    expect(result.duplicateNames).toHaveLength(0);  });});describe('Component Reference Functionality', () => {  const mockCollection: TokenCollection = {    tokens: [],    components: {      'comp1': {        type: 'COMPONENT',        id: 'comp1',        componentSetId: 'compset1',        variantProperties: { size: 'medium', theme: 'primary' }      } as ComponentToken,      'comp2': {        type: 'COMPONENT',         id: 'comp2',        componentSetId: null,        variantProperties: {}      } as ComponentToken    },    componentSets: {      'compset1': {        type: 'COMPONENT_SET',        id: 'compset1',        name: 'Button',        variantPropertyDefinitions: {          size: ['small', 'medium', 'large'],          theme: ['primary', 'secondary']        }      } as ComponentSetToken    },    instances: {      'inst1': {        type: 'INSTANCE',        id: 'inst1',        name: 'Button Instance 1',        remote: false,        componentNode: { id: 'comp1' } as ComponentNode,        variantProperties: { size: 'medium', theme: 'primary' }      } as InstanceToken,      'inst2': {        type: 'INSTANCE',        id: 'inst2',         name: 'Button Instance 2',        remote: false,        componentNode: { id: 'comp1' } as ComponentNode,        variantProperties: { size: 'large', theme: 'secondary' }      } as InstanceToken,      'inst3': {        type: 'INSTANCE',        id: 'inst3',        name: 'Single Use Component',        remote: false,        componentNode: { id: 'comp2' } as ComponentNode,        variantProperties: {}      } as InstanceToken    }  };  describe('shouldExportAsComponentReference', () => {    it('should return true for component set instances', () => {      const result = shouldExportAsComponentReference(mockCollection.instances['inst1'], mockCollection);      expect(result).toBe(true);    });    it('should return true for reused standalone components', () => {      // Add another instance of comp2 to make it reused      const extendedCollection: TokenCollection = {        ...mockCollection,        instances: {          ...mockCollection.instances,          'inst4': {            type: 'INSTANCE',            id: 'inst4',            name: 'Another Single Use Component',            remote: false,            componentNode: { id: 'comp2' } as ComponentNode,            variantProperties: {}          } as InstanceToken        }      };      const result = shouldExportAsComponentReference(extendedCollection.instances['inst3'], extendedCollection);      expect(result).toBe(true);    });    it('should return false for remote components', () => {      const remoteInstance: InstanceToken = {        type: 'INSTANCE',        id: 'remote1',        name: 'Remote Instance',        remote: true,        componentNode: null,        variantProperties: {}      };      const result = shouldExportAsComponentReference(remoteInstance, mockCollection);      expect(result).toBe(false);    });  });  describe('createComponentReferenceToken', () => {    it('should create component reference token with variant information', () => {      const token = createComponentReferenceToken(mockCollection.instances['inst1'], mockCollection);            expect(token.type).toBe('style');      expect(token.property).toBe('component-reference');      expect(token.value).toBe('@include Button--size-medium--theme-primary()');      expect(token.rawValue).toBe('/* Component reference: Button--size-medium--theme-primary */');      expect(token.componentId).toBe('comp1');      expect(token.componentSetId).toBe('compset1');    });    it('should create component reference token for standalone component', () => {      // Add another instance to make it reused      const extendedCollection: TokenCollection = {        ...mockCollection,        instances: {          ...mockCollection.instances,          'inst4': {            type: 'INSTANCE',            id: 'inst4',            name: 'Another Single Use Component',              remote: false,            componentNode: { id: 'comp2' } as ComponentNode,            variantProperties: {}          } as InstanceToken        }      };      const token = createComponentReferenceToken(extendedCollection.instances['inst3'], extendedCollection);            expect(token.type).toBe('style');      expect(token.property).toBe('component-reference');      expect(token.value).toBe('@include Single Use Component()');      expect(token.componentId).toBe('comp2');    });  });});